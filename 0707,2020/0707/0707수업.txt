0707수업

REVIEW
**생성자에 대하여 아는대로 설명하시오**
객체생성시에 자동수행되어 멤버변수들의 값을 특정한 값으로 초기화 할 용도로 사용하는 특수한 메소드이며 
클래스 이름과 같은이름으로 메소드를 만든다.
사용자가 특별히 생성자를 만들지 않으면 자바는 매개변수를 갖지않는 기본생성자를 제공하며
만약 사용자가 생성자를 하나라도 만들기 시작하면 더이상 기본생성자를 제공하지 않는다. 
또 필요하다면 생성자는 중복하여 정의할 수 있다.
중복하여 정의하는 것을 생성자 오버로딩이라고 하며 이를위해서는 매개변수의 개수가 다르거나
자료형이 달라야 한다. 또 생성자속에서 또다른 생성자를 호출하기 위해서는 this() 키워드를 사용할 수 있는데
이때는 반드시 생성자의 첫번째 문장에 와야한다. 

**this와 this()에 대하여 설명하시오**
생성자나 메소드의 매개변수이름을 의미있는이름으로 정해주다보면 멤버변수이름과 겹치게 된다. 이때 멤버 자신을 구별할 목적으로 
this. 키워드를 사용한다.
생성자가 중복정의 되어 있을때 생성자 안에서 또다른 생성자를 호출할수있는데 
이때  this()를 사용한다. 이문장은 반드시 생성자의 첫번째 문장에 와야한다. 

**메소드overloading 과 메소드 overriding 을 비교하여 설명하시오**
* overloading : 같은이름의 메소드를 중복하여 정의할 수 있는 것을 말하며 이때는 매개변수의 개수나 자료형이 달라야함 
* overriding : 상속관계에 있는 자식클래스가 부모의 메소드를 자신에게  맞도록 재정의 하는것을 말하며 이때는 메소드 이름 뿐만 아니라 
매개변수의 개수 및 자료형 까지 일치되게 재정의 해야한다.

**추상메소드와 추상클래스에 대해서 설명하시오**
미래에 만들어질 후손 클래스들이 공통으로 가져야할 속성과 동작들을 일반화 함에 있어 
즉 부모클래스를 만드는 시점에서 후손들이 이 기능을 반드시 가져야 하나 
그 내용을 구체화 할 수 없을때에 메소드 선언부만 명시한다. 
이와같이 메소드의 바디가 없고 선언부만 있는 메소드를 추상메소드라 하고 
메소드 이름앞에 abstract 키워드를 붙인다. 
만약 어떤 클래스가 추상메소드를 하나라도 가지고 있으면 그 클래스 자신이 추상클래스가 되어야 한다. 
역시 클래스이름 앞에 abstract키워드를 붙인다. 
추상클래스는 바디가 구체화 되지 않는 추상메소드를 포함하고 있기 때문에 추상클래스의 객체는 생성할 수 없고 
그것을 구현한 자식클래스를 통해 객체를 생성할 수 있다. 

만약 어떤 클래스가 추상클래스로부터 상속을 하였다면 추상메소드를 자신에 맞게 재정의 하거나
혹은 자신이 추상클래스가 되어야 한다. 

**static 키워드에 대해서 **
어떠한 클래스의 멤버변수나 메소드를 사용하려면 반드시 객체를 생성하고 그 객체를 통해서 사용할 수 있다. 
그런데 만약 객체없이도 사용하려는 멤벼변수 혹은 메소드가 있다면 static 키워드를 붙여 클래스 변수, 클래스 메소드로 만든다.
즉 static 키워드는 변수명, 메소드 명 앞에 올 수 있다. 
일반적으로 클래스의 멤버변수는 객체를 생성해야만 메모리가 확보되고 객체마다 별도의 메모리가 확보된다.
만약 객체와 무관하게 객체없이도 사용하려거나 혹은 모든 객체가 공동으로 사용할 변수가 필요하다면 
변수명 앞에 static 키워드를 붙여 "클래스변수" 로 만든다. 
마찬가지로 일반적으로 클래스의 맴버 메소드는 반드시 객체를 생성하고 그 객체를 통해서 호출할 수 있다. 
그런데 만약 객체와 무관하게 객체없이도 사용하게 하려면 메소드 이름앞에 static 키워드를 붙여 클래스메소드를 만든다. 
객체없이 사용할 수 있기 때문에 객체없이 사용하려면 class 이름으로 접근한다. 
만약 객체가 있다면, 객체를 통해서도 접근할 수 있다. 

클래스 메소드는 객체와 무관하게 사용할 수 있기 때문에 클래스 메소드 안에서는 클래스 멤버에만 접근할 수 있다.
객체를 생성해야만 사용할 수 있는 일반 멤버에는 접근할 수 없다. 


class A {
	int i; //반드시 객체생성뒤 그 객체 생성 뒤 사용가능 : instance member
	static int j;//객체와 무관하게 사용가능 (객체없이도) : 클래스 이름으로 접근- 클래스변수/클래스 메소드라고 함
	public void hello() {
		System.out.println("hello");
	}
	public static void pro() {
		System.out.println("pro");
		//System.out.println(i); i 객체생성 아직 안됨:불법
	}
}

public class Test {

	public static void main(String[] args) {
		A.pro();//클래스.메소드명();
		A ob = new A();
	}

}


**final 키워드에 대해 아는대로 설명하시오**
final 키워드는 변수/클래스/메소드 명 앞에 올 수 있으며 
변수명 앞에 final 은 상수를 만들기 위함이며 처음 정해진 값 의외의 다른 값으로 변경할 수 없다. 
일반적으로 final 변수를 만들때는 다른 멤버변수와 구별하기 위하여 모두 대문자로 표현한다. 
또 변경할 수 없읜 객체마다 따로 확보할 필요가 없다. 그래서 대체로 final 은 static 키워드와 같이 사용한다. 
메소드 이름앞에 final 은 일반적으로 상속관계 있을때 자식클래스는 부모의 메소드를 자신에게 맞도록 재정의 할 수있음
그러나 final메소드는 재정의 할 수 없다. 따라서 미래에 만들어질 후손들에게 재정의 금지를 위한다면 메소드 이름앞에 final 을 붙인다.
또 일반적으로 자바의 클래스 세상에서는 이미 만들어진 클래스를 상속받아 새로운 클래스를 만들 수 있다. 그런데 만약 클래스 이름앞에
final이 있다면 확장하여 상속할 수 없다. 즉, 어떤 클래스를 만들때에 상속을 금지시키고자 한다면 클래스 이름앞에 final을 붙인다. 


**추상클래스와 인터페이스를 비교하여 설명하시오 **
추상클래스와 인터페이스 모두 미래에 만들어질 후손클래스들이 가져야할 공통적인 속성과 동작을 뽑아 일반화 하기 위해 사용한다. 
그러나 추상클래스는 바디가 구체화된 메소드를 포함 할 수 있으며 인터페이스는 
완전 추상의 개념으로 추상메소드와 상수만으로 구성이 되있음.
또 자바에서는 클래스의 다중상속이 금지되어 있어 다중상속에 효과를 기대할 목적으로 인터페이스를 이용한다. 

**instanceof 의 연산자에 대해 설명하시오**
상속관계에 있을때 부모의 참조변수는 자식클래스의 객체를 참조할 수 있다. 
그러나 자식클래스에서 추가된 메소드를 직접 사용할 수는 없고 형변환 하여 사용해야 한다.
그러나 자식클래스의 종류가 여럿 있을때 특정 자식클래스인지 판별하기 위하여 instanceof 연산자를 이용한다. 

ex) 모든 도형들이 가져야할 공통적인 속성과 동작을 갖는 Shape 클라스가 있고 이를 확장한 이차원 도형을 표현한 TwoDimShape 이 있고
삼차원 도형을 표현한 ThreeDimShap  이 있다고 하자. 
또 TwoDimShape 을 확장한 Rectangle,Circle 이 있고
ThreeDimShape 을 확장한 Cube, Cylinder 가 있다고 할때 

어떠한 도형이라도 담을 수 있는 배열을 만들어야 한다면 배열의 자료형은 Shape 으로 만들어야 할 것이다. 
이제 Shape 자료형의 배열에 온갖 도형들이 담겨 있다고 가정하자. 
배열의 요소를 하나씩 꺼내와서 만약 그것이 이차원 도형이면 면적계산을 해야하고 
만약 그것이 삼차원 도형이면 부피계산을 시켜야함. 그 객체의 종류에 따라 시켜야 하는 일이 다름. 
또 부모의 참조변수가 자식클래스에서 추가된 "면적계산" "부피계산" 하는 메소드를 직접 호출할 수 없고
면적계산을 시키려면 TwoDimShape 으로 형변환 해야하고 "부피계산"울 시키려면 ThreeDimShape 으로 형변환 해야한다. 
그래서 뽑아온 객체가 어떤 후손인지 판별하여 형변환을 헤야한다. 
그때 사용하는 연산자가 instanceof 이다.

**call by value call by reference 에 대하여 설명하시오**
메소드 호출 시에 기본자료형이 전달 되는 것을 call by value 라고 하며 메소드 안에서 변경된 내용이 메소드 호출한 쪽에 적용안됨. 
메소드 호출 시에 배열이나 객체 참조변수가 전달되는 것을 call by reference 라고 하며 메소드 안에서 
변경된 내용 메소드 호출한 쪽이 적용이 된다. 
 
**메소드 재귀호출에 대하여 설명하시오**
메소드 안에서 계속하여 자신을 호출하는 것을 말한다. 이때는 반드시 종료하는 조건이 필요하다.
그렇지 않으면 문제가 발생 

**super 와 super() 에 대해서 설명하라**
super는 상속관계에 있을때 부모클래스의 동일한 멤버변수나 메소드를 자식클래스에서 정의하면
부모의 동일한 멤버는 가려지게 되고 자식클래스의 멤버가 우선순위가 높다. 
이때 부모클래스의 동일한 멤버에 접근하기 위해  super 키워드를 사용한다. 
super()는 역시 상속관계에 있을때 자식클래스의 생성자에서 부모클래스의 생성자를 명시하기 위하여 사용한다. 
부모의 기본생성자를 요구하는  super() 즉 매개변수를 갖지않는 생성자는 생략 할수있지만
만약 부모의 매개변수를 갖는 생성자가 동작되기를 기대한다면 반드시  super(값1, 값2).. 를 명시해야한다. 

**Object class, toString, equals 에 대하여 설명하라**
Object 클래스는 모든 클래스들의 최상위 클래스이며 자바의 모든 클래스와 내가 만드는 클래스는 자동으로 Object의 후손클래스임.
따라서 모든 클래스들은 Object의 메소드를 자유롭게 사용할 수 있으며 필요하다면 자신에게 맞도록 재정의 할 수 있음.
그중에 toString 과 equals를 가장 많이 사용한다. 
toString은 객체의 속성값을 출력문에 사용하거나 문자열로 표현하기 위하여 사용되는 메소드. 
equals는 두개의 객체가 동일한 속성값을 갖고 있는지 판별하는 용도로 사용한다.
만약  toString을 오버라이딩 하지 않는다면 부모의 즉 Object 의 toString이 호출되는데 이것은 
그 객체가 어떤 자료형이며 어떤 메모리를 참조하는지 반환하도록 설계되어 있음. 
또 equals를 오버라이딩 하지 않는다면 마치 == 연산자를 이용한것과 같이 두개의 객체가 동일한 메모리를 바라보는지 
비교한 결과를 반환한다. 